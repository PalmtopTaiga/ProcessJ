info() ::= <<
 This file contains all templates for the ProcessJ compiler based on the grammar of
 ProcessJ. The CodeGeneratorC.java file then uses these rules as well as a visitor
 to generate our C equivalent code.
>>


Compilation(pragmas, packageName, imports, typeDecls, prototypes, parBlockPrototypes,
  parBlockProcs, functionToCall) ::= <<
<! TODO pragmas, packageName, imports !>
#include \<stdio.h>
#include \<cif.h>
#include \<stdbool.h>

<commentBar()>
<if(prototypes)><prototypes; separator = ";\n">;<endif>
<if(parBlockPrototypes)><\\>
<commentBar()>
/*These functions were auto-generated by the compiler from ParBlock declarations: */
<parBlockPrototypes; separator = ";\n">;
<endif>
<commentBar()>
<cMainFunction(functionToCall)>
<commentBar()>
<typeDecls;
 separator ="\n/*========================================================================================*/\n">
<! These are the actual functions generated by our ParBlock !>
<if(parBlockProcs)><\\>
<commentBar()>
/*This functions were auto-generated by the compiler from ParBlock declarations: */
<commentBar()>
<parBlockProcs;
 separator ="\n/*========================================================================================*/\n">
<commentBar()>
<endif>
>>


Assignment(left, right, op) ::= <<
(<left> <op> <right>)
>>


BinaryExpr(left, right, op) ::= "(<left> <op> <right>)"


BreakStat() ::= "break"


ChannelWriteStat(globalWsName, channel, expr) ::= <<
ChanOutInt(<globalWsName>, <channel>, <expr>)
>>


ChannelReadExprInt(globalWsName, channel) ::= <<
({ int tempReadVar;
   ChanInInt(<globalWsName>, <channel>, &tempReadVar);
   tempReadVar;
})
>>


ChannelReadExprTimer(globalWsName, channel) ::= <<
TimerRead(<globalWsName>)
>>


TimeoutStat(globalWsName, delay) ::= <<
TimerDelay(<globalWsName>, <delay>)
>>


CastExpr(ct, expr) ::= "((<ct>) <expr>)"


ContinueStat() ::= "continue"


DoStat(stat, expr) ::= <<
do{
  <stat; separator = ";\n">;
}while( <expr> )
>>


IfStat(expr, thenPart, elsePart) ::= <<
if( <expr> ) {
  <thenPart; separator = ";\n">;
}<if(elsePart)> else {
  <elsePart; separator = ";\n">;
}<endif>
>>


InvocationWithReturn(functionName, paramNumber, globalWorkspace, procParams, returnType) ::= <<
({
  <returnType> returnValue;
  functionName(<globalWorkspace>, <procParams; separator =", ">, &returnType);
  returnValue;
})
>>

InvocationNoReturn(functionName, paramNumber, workspace, procParams) ::= <<
<functionName>(<workspace>, <procParams; separator =", ">)
>>


InvocationPar(wordName, workspaceName, paramNumber, functionName, stackSize,
           paramWorkspaceName, procParams) ::= <<
<! Similar to above but used to create par blocks instead and only sets up needed calls
   separate method (below) actually does the calling to the ProcPar. !>
/*Process for <functionName> function.*/
word <wordName> = WORKSPACE_SIZE(<paramNumber>, <stackSize>); /*paramCount and stackSize. */
Workspace <workspaceName> = MAlloc (<paramWorkspaceName>, sizeof (word) * <wordName>);
<workspaceName> = LightProcInit(<paramWorkspaceName>, <workspaceName>, <paramNumber>, <stackSize>);

<if(procParams)><procParams; separator = ";\n">;<endif>
>>


ProcPar(paramWorkspaceName, processNumber, list) ::= <<
<! list is a list of strings alternating between the workspace form process n and the
   name of process n. Ex: { "ws1", "source", "ws2", "writer", "ws3", "doubleValue",... !>


ProcPar(<paramWorkspaceName>, <processNumber>, <list; separator = ", ">);
>>


ForStat(init, expr, incr, barriers, stats) ::= <<
for(<init; separator = ",">; <expr>; <incr>){
  <stats; separator = ";\n">;
}
>>


ReturnStat(expr) ::= "return<if(expr)> <expr><endif>"

ParBlock(stringStats, procPar ) ::= <<
{ /*This is our Par Block. Run in parallel. */
  <stringStats; separator = "\n\n">
  <procPar>
}
>>


ProcTypeDecl(modifiers, returnType, name, formals, implement, body, workspace, last) ::= <<
<modifiers><returnType> <name>(Workspace <workspace><\\>
  <if(formals)>,<formals; separator = ", "><endif>)<implement>{
  <body; separator = ";\n">;<\\>

  <if(last)>

  shutDownLabel:
    Shutdown(<workspace>);<endif>
  <!TODO return type !>

}
>>

ParBlockProc(name, body, paramWorkspaceName, getParameters) ::= <<
<! Very similar to ProcTypeDecl but simplified for ParBlocks only. !>
void <name>(Workspace <paramWorkspaceName>){
  <if(getParameters)><getParameters; separator = ";\n">;<endif>
  <body>;

  return;
}
>>


LocalDecl(type, var, constant, channelPart) ::= <<
<! If this is channel it must be initialized! !>
<type> <var><if(channelPart)>MyChannel, *<var> = &<var>MyChannel; <channelPart><endif>
>>


SwitchLabel(constExpr) ::= "case <constExpr>:"

SwitchGroup(labels, stmts) ::= <<
  <labels; separator = "\n">
    <stmts; separator = ";\n">;
>>

SwitchStat(expr, switchGroups) ::= <<
switch( <expr> ){
  <switchGroups; separator = "\n">
}
>>


Ternary(expr, trueBranch, falseBranch) ::= "<expr> ? <trueBranch> : <falseBranch>"


UnaryPostExpr(expr, op) ::= "((<expr>) <op>)"


UnaryPreExpr(expr, op) ::= "(<op> (<expr>))"

WhileStat(expr, stat) ::= <<
while( <expr> ) {
  <stat; separator = ";\n">;
}
>>


Var(name, init) ::= "<name><if(init)> = <init><endif>"


commentBar() ::= "/*======================================================================================*/"


cMainFunction(functionToCall) ::= <<
int main(int argc, char** argv){
  int ccspResults;
  Workspace ws;

  /*Initialize CCSP*/
  ccspResults = ccsp_init();
  if(!ccspResults){
    printf("Error starting CCSP, exiting...\n");
    return 1;
  }

  ws = ProcAllocInitial(0, 1024 * 1024);
  ProcStartInitial(ws, <functionToCall>);
  return 0;
}
>>


prototype(name, formals, workspace) ::= <<
void <name>(Workspace <workspace><if(formals)>, <formals; separator = ", "><endif>)
>>


printfNoArgs(string) ::= "printf(\"<string>\")"


printf(string, argumentList) ::= <<
printf("<string>", <argumentList; separator = ", ">)
>>


procParam(globalWsName, wsName, number, param) ::= <<
ProcParam(<globalWsName>, <wsName>, <number>, <param>)
>>


procGetParam(type, name, number, globalWsName) ::= <<
<type> <name> = ProcGetParam(<globalWsName>, <number>, <type>)
>>


ChanInit(globalWsName, channelName) ::= "ChanInit(<globalWsName>, <channelName>)"


CompoundStatement(param) ::= "<param>"


AltStat(altType, enableChannelList, waitType, disableChannelList,
        switchStatement) ::= <<
<! This is the main statement to create our AltCase, we have auxillary functions
   to fill the rest of it in... !>
/*Start of Alternative!*/
<altType>;

<enableChannelList; separator = ";\n">;

/*Do waiting here! */
<waitType>;

<disableChannelList; separator = ";\n">;

<switchStatement>

/*End of Alternative!*/
>>

NormalAltType(globalWsName) ::= "Alt(<globalWsName>)"
TimerAltType(globalWsName) ::= "TimerAlt(<globalWsName>)"


NormalWaitType(globalWsName) ::= "AltWait(<globalWsName>)"
TimerWaitType(globalWsName) ::= "TimerAltWait(<globalWsName>)"


AltEnableTimeout(globalWsName, number, time, name) ::= <<
<! This statement is funny as we actually need a variable to hold our time. !>
Time <name> = TimerRead(<globalWsName>) + <time>;
AltEnableTimer(<globalWsName>, <number>, <name>)
>>


AltEnableSkip(globalWsName, number) ::= "AltEnableSkip(<globalWsName>, <number>)"
AltEnableChannel(globalWsName, number, name) ::= "AltEnableChannel(<globalWsName>, <number>, <name>)"


AltDisableTimeout(globalWsName, number, name) ::= <<
AltDisableTimer(<globalWsName>, <number>, <name>)
>>


AltDisableChannel(globalWsName, number, name) ::= "AltDisableChannel(<globalWsName>, <number>, <name>)"
AltDisableSkip(globalWsName, number) ::= "AltDisableSkip(<globalWsName>, <number>)"


AltSwitch(altEnd, caseList) ::= <<
<! Our Switch Statement is a list of cases separated by breaks. !>
switch( <altEnd> ){
  <caseList; separator ="\n">
  default:
    printf("Reached default case of switch statement from Alt\n");
    printf("This should never happen... dying now X(\n");
    exit(1);
}
>>

AltCase(number, guardToDo, statementList) ::= <<
case <number>:
  <guardToDo>;
  <statementList; separator = ";\n">;
  break;
>>


AltEnd(globalWsName) ::= "AltEnd( <globalWsName> )"


ParamDecl(type, name) ::= "<type> <name>"