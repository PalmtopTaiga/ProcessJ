info() ::= <<
 This file contains all templates for the ProcessJ compiler based on the grammar of
 ProcessJ. The CodeGeneratorC.java file then uses these rules as well as a visitor
 to generate our C equivalent code.
>>


Compilation(pragmas, packageName, imports, typeDecls, prototypes, functionToCall) ::= <<
<! TODO pragmas !>
<! TODO packageName !>
<! TODO imports !>
#include \<stdio.h>
#include \<cif.h>
<! ADD other C headers here?? !>
<commentBar()>
<prototypes; separator = ";\n"><if(prototypes)>;<endif>
<commentBar()>
<cMainFunction(functionToCall)>
<commentBar()>
<typeDecls; separator =
"\n/*======================================================================================*/\n">
>>


Assignment(left, right, op) ::= <<
(<left> <op> <right>)
>>


BinaryExpr(left, right, op) ::= "(<left> <op> <right>)"


BreakStat() ::= "break"


ChannelWriteStat(globalWsName, channel, expr) ::= <<
ChanOutInt(<globalWsName>, <channel>, <expr>)
>>


ChannelReadExpr(globalWsName, channel) ::= <<
({ int tempReadVar;
   ChanInInt(<globalWsName>, <channel>, &tempReadVar);
   tempReadVar;
})
>>


CastExpr(ct, expr) ::= "((<ct>) <expr>)"


ContinueStat() ::= "continue"


DoStat(stat, expr) ::= <<
do{
  <stat; separator = ";\n">;
}while( <expr> )
>>


IfStat(expr, thenPart, elsePart) ::= <<
if( <expr> ) {
  <thenPart; separator = ";\n">;
}<if(elsePart)> else {
  <elsePart; separator = ";\n">;
}<endif>
>>


Invocation(barrierName, wordName, workspaceName, paramNumber, functionName, stackSize,
           paramWorkspaceName, procParams) ::= <<
/* Running a proc requires a barrier. */
LightProcBarrier <barrierName>;

/*Initialize barrier by giving it the number of processes that will run with it, in this
  case just 1 as well as the barrier's address. */
LightProcBarrierInit (<paramWorkspaceName>, &<barrierName>, 1);

/*Process for <functionName> function.*/
word <wordName> = WORKSPACE_SIZE(<paramNumber>, <stackSize>); /*paramCount and stackSize. */
Workspace <workspaceName> = MAlloc (<paramWorkspaceName>, sizeof (word) * <wordName>);
/*Initialize process by giving it the number of parameters it will take in as well
  as it's workspace. */
<workspaceName> = LightProcInit(<paramWorkspaceName>, <workspaceName>, <paramNumber>, <stackSize>);
<!Add parameters if any here !>
<if(procParams)><procParams; separator = ";\n">;<endif>

/*Run process! */
LightProcStart(<paramWorkspaceName>, &<barrierName>, <workspaceName>, <functionName>)
>>


InvocationPar(wordName, workspaceName, paramNumber, functionName, stackSize,
           paramWorkspaceName, procParams) ::= <<
<! Similar to above but used to create par blocks instead and only sets up needed calls
   separate method (below) actually does the calling to the ProcPar. !>
/*Process for source function.*/
word <wordName> = WORKSPACE_SIZE(<paramNumber>, <stackSize>); /*paramCount and stackSize. */
Workspace <workspaceName> = MAlloc (<paramWorkspaceName>, sizeof (word) * <wordName>);
/*Initialize process by giving it the number of parameters it will take in as well
  as it's workspace. */
<workspaceName> = LightProcInit(<paramWorkspaceName>, <workspaceName>, <paramNumber>, <stackSize>);
<!Add parameters if any here !><\\>
<if(procParams)><procParams; separator = ";\n">;<endif>
>>


ProcPar(paramWorkspaceName, processNumber, list) ::= <<
<! list is a list of strings alternating between the workspace form process n and the
   name of process n. Ex: { "ws1", "source", "ws2", "writer", "ws3", "doubleValue",... !>
ProcPar(<paramWorkspaceName>, <processNumber>, <list; separator = ", ">);
>>


ForStat(init, expr, incr, barriers, stats) ::= <<
for(<init; separator = ",">; <expr>; <incr>){
  <stats; separator = ";\n">;
}
>>


ReturnStat(expr) ::= "return<if(expr)> <expr><endif>"


ParamDecl(type, name, constant) ::= "<if(constant)>const <endif><type> <name>"


ParBlock(stringStats, procPar ) ::= <<
{
  <stringStats; separator = "\n\n">
  <procPar>
}
>>


ProcTypeDecl(modifiers, returnType, name, formals, implement, body, paramWorkspaceName,
             getParameters) ::= <<
<modifiers><returnType> <name> (<formals; separator = ", ">) <implement>{
  <if(getParameters)><getParameters; separator = ";\n">;<endif>
  <body; separator = ";\n">;<\\>
  <if(paramWorkspaceName)><\n>shutDownLabel:<\n>    Shutdown(<paramWorkspaceName>);<endif>
}
>>


LocalDecl(type, var, constant, channelPart) ::= <<
<! If this is channel it must be initialized! !>
<type> <var><if(channelPart)>;
<channelPart><endif>
>>


SwitchLabel(constExpr) ::= "case <constExpr>:"

SwitchGroup(labels, stmts) ::= <<
  <labels; separator = "\n">
    <stmts; separator = ";\n">;
>>

SwitchStat(expr, switchGroups) ::= <<
switch( <expr> ){
  <switchGroups; separator = "\n">
}
>>


Ternary(expr, trueBranch, falseBranch) ::= "<expr> ? <trueBranch> : <falseBranch>"


UnaryPostExpr(expr, op) ::= "((<expr>) <op>)"


UnaryPreExpr(expr, op) ::= "(<op> (<expr>))"

WhileStat(expr, stat) ::= <<
while( <expr> ) {
  <stat; separator = ";\n">;
}
>>


Var(name, init) ::= "<name><if(init)> = <init><endif>"


commentBar() ::= "/*======================================================================================*/"


cMainFunction(functionToCall) ::= <<
int main(int argc, char** argv){
  int ccspResults;
  Workspace ws;

  /*Initialize CCSP*/
  ccspResults = ccsp_init();
  if(!ccspResults){
    printf("Error starting CCSP, exiting...\n");
    return 1;
  }

  ws = ProcAllocInitial(0, 1024 * 1024);
  ProcStartInitial(ws, <functionToCall>);
  return 0;
}
>>

prototype(name, workspaceName) ::= "void <name>(Workspace <workspaceName>)"

printfNoArgs(string) ::= "printf(\"<string>\")"

printf(string, argumentList) ::= <<
printf("<string>", <argumentList; separator = ", ">)
>>

procParam(globalWsName, wsName, number, param) ::= <<
ProcParam(<globalWsName>, <wsName>, <number>, <param>)
>>

procGetParam(type, name, number, globalWsName) ::= <<
<type> <name> = ProcGetParam(<globalWsName>, <number>, <type>)
>>

ChanInit(globalWsName, channelName) ::= "ChanInit(<globalWsName>, &<channelName>)"