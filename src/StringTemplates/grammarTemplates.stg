info() ::= <<
 This file contains all templates for the ProcessJ compiler based on the grammar of
 ProcessJ. The CodeGeneratorC.java file then uses these rules as well as a visitor
 to generate our C equivalent code.
>>


Compilation(pragmas, packageName, imports, typeDecls, prototypes, functionToCall) ::= <<
<! TODO pragmas !>
<! TODO packageName !>
<! TODO imports !>
#include \<stdio.h>
#include \<cif.h>
<! ADD other C headers here?? !>
<commentBar()>
<prototypes; separator = ";\n"><if(prototypes)>;<endif>
<commentBar()>
<cMainFunction(functionToCall)>
<commentBar()>
<typeDecls; separator = "\n\n">
>>


Assignment(left, right, op) ::= <<
(<left> <op> <right>)
>>


BinaryExpr(left, right, op) ::= "(<left> <op> <right>)"


BreakStat() ::= "break"


CastExpr(ct, expr) ::= "((<ct>) <expr>)"


ContinueStat() ::= "continue"


DoStat(stat, expr) ::= <<
do{
  <stat; separator = ";\n">;
}while( <expr> )
>>


IfStat(expr, thenPart, elsePart) ::= <<
if( <expr> ) {
  <thenPart; separator = ";\n">;
}<if(elsePart)> else {
  <elsePart; separator = ";\n">;
}<endif>
>>


Invocation(barrierName, wordName, workspaceName, paramNumber, functionName, stackSize,
           paramWorkspaceName) ::= <<
<! We need a special name for the barrier, word, and workspace as if we have multiple
 functions these will need to be unique for each !>
/* Running a proc requires a barrier. */
LightProcBarrier <barrierName>;

/*Initialize barrier by giving it the number of processes that will run with it, in this
  case just 1 as well as the barrier's address. */
LightProcBarrierInit (<paramWorkspaceName>, &<barrierName>, 1);

/*Process for source function.*/
word <wordName> = WORKSPACE_SIZE(0, <stackSize>); /*Zero is the number of arguments. */
Workspace <workspaceName> = MAlloc (<paramWorkspaceName>, sizeof (word) * <wordName>);
/*Initialize process by giving it the number of parameters it will take in as well
  as it's workspace. */
<workspaceName> = LightProcInit(<paramWorkspaceName>, <workspaceName>, <paramNumber>, <stackSize>);

/*Run process! */
LightProcStart(<paramWorkspaceName>, &<barrierName>, <workspaceName>, <functionName>);
Shutdown(<paramWorkspaceName>)
>>


ForStat(init, expr, incr, barriers, stats) ::= <<
for(<init; separator = ",">; <expr>; <incr>){
  <stats; separator = ";\n">
}
>>


ReturnStat(expr) ::= "return<if(expr)> <expr><endif>;"


ParamDecl(type, name, constant) ::= "<if(constant)>const <endif><type> <name>"


ProcTypeDecl(modifiers, returnType, name, formals, implement, body) ::= <<
<modifiers><returnType> <name> (<formals; separator = ", ">) <implement> {
  <body; separator = ";\n">
}
>>


LocalDecl(type, var, constant) ::= "<type> <var>"


SwitchLabel(constExpr) ::= "case <constExpr>:"

SwitchGroup(labels, stmts) ::= <<
  <labels; separator = "\n">
    <stmts; separator = ";\n">;
>>

SwitchStat(expr, switchGroups) ::= <<
switch( <expr> ){
  <switchGroups; separator = "\n">
}
>>


Ternary(expr, trueBranch, falseBranch) ::= "<expr> ? <trueBranch> : <falseBranch>"


UnaryPostExpr(expr, op) ::= "((<expr>) <op>)"


UnaryPreExpr(expr, op) ::= "(<op> (<expr>))"

WhileStat(expr, stat) ::= <<
while( <expr> ) {
  <stat; separator = ";\n">;
}
>>


Var(name, init) ::= "<name><if(init)> = <init><endif>"


commentBar() ::= "/*======================================================================================*/"


cMainFunction(functionToCall) ::= <<
int main(int argc, char** argv){
  int ccspResults;
  Workspace ws;

  /*Initialize CCSP*/
  ccspResults = ccsp_init();
  if(!ccspResults){
    printf("Error starting CCSP, exiting...\n");
    return 1;
  }

  ws = ProcAllocInitial(0, 1024 * 1024);
  ProcStartInitial(ws, <functionToCall>);
  return 0;
}
>>

prototype(name, workspaceName) ::= "void <name>(Workspace <workspaceName>)"

printfNoArgs(string) ::= "printf(\"<string>\")"

printf(string, argumentList) ::= <<
printf("<string>", <argumentList; separator = ", ">)
>>