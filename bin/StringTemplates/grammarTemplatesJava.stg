delimiters "<",">"

Info() ::= <<
 This file contains all templates for the ProcessJ compiler based on the grammar of
 ProcessJ. The CodeGeneratorJava.java file then uses these rules as well as a visitor
 to generate our Java equivalent code.
>>

Compilation(pragmas, packageName, imports, typeDecls,
  parBlockProcs) ::= <<
<! TODO pragmas, packageName, imports !>

package Generated<if(packageName)>.<packageName><endif>;
import java.util.*;
import ProcessJ.runtime.Process;
import ProcessJ.runtime.Timer;
import ProcessJ.runtime.*;

public class <packageName> { <! add and use className and extends/implements if needed. !>
	<typeDecls;
 		separator ="\n">
}
>>

AltStat(caseCount, altSwitchGroup, timers, initBoolGuards, initGuards, jmp1, jmp2, timerKills) ::= <<
final Alt alt = new Alt(<caseCount>, this);	
<timers>
<initGuards>
<initBoolGuards>

boolean bRet = alt.setGuards(boolGuards, guards);

if (!bRet) {
	System.out.println("RuntimeException: One of the boolean guards needs to be true!!");
	System.exit(1);
}

label(<jmp1>);	

int chosen = alt.getReadyGuardIndex();
<if(altSwitchGroup)><altSwitchGroup><endif>

if (chosen == -1) {
	this.runLabel = <jmp1>;
	yield();	
} else {
	<if(timerKills)><timerKills; separator=";\n"><endif>
	this.runLabel = <jmp2>;
	yield();
}

label(<jmp2>);
>>

AltSwitchGroup(cases) ::= <<
<if(cases)>
switch(chosen) {
	<cases; separator=";\n">;
}
<endif>
>>

AltCase(number, statementList) ::= <<
case <number>: 
  	<if(statementList)><statementList; separator = ";\n">;<endif>
	break
>>

AltBooleanGuardsArr(tempExprs, constants) ::= <<
<if(tempExprs)><tempExprs; separator=";\n">;<endif>
<if(constants)>boolean[] boolGuards = {<constants; separator=", ">};<endif>	
>>

AltGuardsArr(guards) ::= <<
<if(guards)>Object[] guards = {<guards; separator=", ">};<endif>
>>

AltTimerKill(timer) ::= <<
<if(timer)>
if (<timer>.started && !<timer>.stopped) {
	<timer>.kill();
}	
<endif>
>>

AltTimerStart(timer) ::= <<
<if(timer)>	
if (!<timer>.started) {
	try {
		<timer>.start();
	} catch (InterruptedException e) {
		System.out.println("InterruptedException!");
	}
}
<endif>
>>

Assignment(left, right, op) ::= "<left> <op> <right>"

BinaryExpr(left, right, op) ::= "(<left> <op> <right>)"

BreakStat() ::= "break"

CastExpr(ct, expr) ::= "(<ct>) (<expr>)"

ChannelWriteStat(channel, expr, jmp0, jmp1, shared) ::= <<

<!switch(runLabel) {
	case <jmp0>: resume(<jmp0>); break;
	case <jmp1>: resume(<jmp1>); break;
}!>

label(<jmp0>);
if (<channel>.isReadyToWrite()) {
	<channel>.write(this, <expr>);
	this.runLabel = <jmp1>;
	yield();
} else {
	<if(shared)><channel>.addWriter(this);<endif>
	setNotReady();
	this.runLabel = <jmp0>;
	yield();
}
	
label(<jmp1>)
>>

ChannelReadExpr(left, channel, alt, jmp0, jmp1) ::= <<
<if(alt)>
<left> = <channel>.read(this);
<else>
label(<jmp0>);
if(<channel>.isReadyToRead(this)) {
<if(left)>
	<left> = <channel>.read(this);
<else>
	<channel>.read(this);
<endif>
	this.runLabel = <jmp1>;
	yield();
} else {
	setNotReady();
	<channel>.addReader(this);
	this.runLabel = <jmp0>;
	yield();
}
label(<jmp1>)<\\>
<endif>
>>

ChannelReadExprExtRv(left, channel, alt, extRv, jmp0, jmp1) ::= <<
<if(alt)>
<left> = <channel>.readPreRendezvous(this);
<extRv; separator=";\n">
<channel>.readPostRendezvous(this);
<else>
label(<jmp0>);
if(<channel>.isReadyToRead(this)) {
<if(left)>
	<left> = <channel>.readPreRendezvous(this);
	<extRv; separator=";\n">;
	<channel>.readPostRendezvous(this);
<else>
	<channel>.readPreRendezvous(this);
	<extRv; separator=";\n">;
	<channel>.readPostRendezvous(this);
<endif>
	this.runLabel = <jmp1>;
	yield();
} else {
	setNotReady();
	<channel>.addReader(this);
	this.runLabel = <jmp0>;
	yield();
}
label(<jmp1>)<\\>
<endif>
>>

ConstantDecl(type, var) ::= "public static final <type> <var>;"

ClaimStat(stats, channels, jmp) ::= <<
label(<jmp>);
<if(channels)>if(<channels:{c | !<c>.claim() }; separator = "||">) {
	<channels: {uc | <uc>.unclaim();}; separator="\n">
	this.runLabel = <jmp>;
	yield();
}
<endif>
<stats; separator=";\n">;
<channels:{c | <c>.unclaim()}; separator = ";\n">;
>>

ClaimStatClaimPart(c, unclaims, jmp) ::= <<
label(<jmp>);
if (!<c>.claim()) {
	<c>.awaitClaim(this);
	<unclaims: {uc | <uc>.unclaim();}; separator="\n">
	setNotReady();
	this.runLabel = <jmp>;
	yield();
}
>>

TimerReadExpr(left, timer) ::= <<
<left> = <timer>.read()
>>

ContinueStat() ::= "continue"

DoStat(stat, expr) ::= <<
do {
  <stat; separator = ";\n">;
} while( <expr> )
>>

ForStat(init, expr, incr, stats) ::= <<
for(<init; separator = ",">; <expr>; <incr>){
  <stats; separator = ";\n">;
}
>>

ParForStat(parName, init, expr, incr, barriers, stats, jmp0, jmp1) ::= <<
label(<jmp0>);	
final Par <parName> = new Par(-1, this);
int cnt = 0;	
List\<Process> pp = new LinkedList\<Process>(); 

for(<init; separator = ",">; <expr>; <incr>){
	cnt++;
	pp.add(
		<stats; separator=";\n">
	);
}
//set the process count	
<parName>.setProcessCount(cnt);

//schedule all the processes
for(Process p : pp) {
	p.schedule();
}
setNotReady();
this.runLabel = <jmp1>;
yield();
label(<jmp1>)
>>

IfStat(expr, thenPart, elsePart) ::= <<
if( <expr> ) {
  <thenPart; separator = ";\n">;
}<if(elsePart)> else {
  <elsePart; separator = ";\n">;
}<endif>
>>

InvocationNormal(qualifiedProc, procParams, isProcess, par, parName, barriers) ::= <<
<if(isProcess)>
<if(par)>
(new <qualifiedProc>(<if(procParams)> <procParams; separator =", "> <endif>){
  public void finalize() {
    <parName>.decrement();    
	<if(barriers)><barriers:{b | <b>.resign()}; separator = ";\n">;<endif>
  }
}).schedule()<\\>
<endif>
<else>
<qualifiedProc>(<if(procParams)> <procParams; separator =", "> <endif>)<\\>
<endif>
>>

InvocationWithChannelReadExprParam(left, right, paramBlocks) ::= <<
<if(paramBlocks)><paramBlocks; separator=";\n\n">;<endif>
<if(left)><left>=<endif><right>
>>

LocalDeclNormalProc(typeStr, var, chanType, protoOrRecType, barrierType, rEmpty) ::= <<
<if(chanType)>
<typeStr> <var><if(rEmpty)> = new <typeStr>()<endif><\\>
<elseif(protoOrRecType)>
<typeStr> <var><if(rEmpty)> = null<endif><\\>
<elseif(barrierType)>
<typeStr> <var><if(rEmpty)> = new Barrier()<endif><\\>
<else>
<typeStr> <var><\\>
<endif>
>>

LocalDeclYieldingProc(typeStr, var, chanType, protoOrRecType, barrierType, rEmpty) ::= <<
<if(chanType)>
<var><if(rEmpty)> = new <typeStr>()<endif><\\>
<elseif(protoOrRecType)>
<var><if(rEmpty)> = null<endif><\\>
<elseif(barrierType)>
<var><if(rEmpty)> = new Barrier()<endif><\\>
<else>
<if(!rEmpty)><var><endif><\\>
<endif>
>>

NewArray(type, size) ::= "new <type>[<size>]"

ParamDecl(type, name) ::= "<type> <name>"

ProcTypeDeclToProcess(modifiers, returnType, retstatFound, packageName, name, formals, formalNames, globals, implement, lookupswitch, body, mainMethod, foreverloop) ::= <<

public static class <name> extends Process {

	<if(formals)><formals; separator = ";\n">;<endif>
	<if(globals)><globals; separator = ";\n">;<endif>

    <!modifiers><returnType> <name>(<\\!>
    public <name>(<\\>
    	<if(formals)><formals; separator = ", "><endif>) {
    	<if(formalNames)><formalNames:{n | this.<n> = <n>}; separator = ";\n">;<endif>
    }

	@Override
	public synchronized void run() {
		<lookupswitch>
		<body; separator = ";\n">;
		<if(!retstatFound && !foreverloop)>terminate();<endif>
	}
}

<if(mainMethod)><mainMethod><endif>
>>

ProcTypeDeclToMain(qualifiedProc) ::= <<
public static void main(String[] args) {
	Scheduler scheduler = new Scheduler();

	Process.scheduler = scheduler;
	System.out.println("Added _main process to scheduler...");
		
	(new <qualifiedProc>(args)).schedule();
	
	System.out.println("Starting the scheduler...");
	Process.scheduler.start();
		
	System.out.println("Scheduler thread.start() done.");
}
>>
			
ProcTypeDeclToMethod(modifiers, returnType, retstatFound, packageName, name, formals, formalNames, globals, implement, body, last, foreverloop) ::= <<

public static <returnType> <name>(<if(formals)><formals; separator = ", "><endif>) {
	<body; separator = ";\n">;
}
>>

ProtocolLiteral(protocolName, tagName, params, tag) ::= <<
new <protocolName>(new <protocolName>.<tagName>(<if(params)><params; separator=", "><endif>), <protocolName>.Tag.<tag>)
>>

ProtocolCase(name, recMems, recMemNames) ::= <<
public static class <name> extends ProtocolCase {
	<if(recMems)><recMems:{n | public <n>}; separator=";\n">;<endif>
	public <name>(<if(recMems)><recMems; separator=", "><endif>) {
    	<if(recMemNames)><recMemNames:{n | this.<n> = <n>}; separator = ";\n">;<endif>
	}
}
>>

ProtocolTypeDecl(name, cases, caseNames) ::= <<
public static class <name> {
	<if(caseNames)>public enum Tag { <caseNames; separator=", "> };<endif>
	<cases; separator = "\n">
	ProtocolCase data;
    Tag tag;
    public <name>(ProtocolCase data, Tag tag) {
		this.data = data;
		this.tag = tag;
   }
}
>>

RecordTypeDecl(name, recMems, recMemNames) ::= <<
public static class <name> {
	<if(recMems)><recMems:{n | public <n>}; separator=";\n">;<endif>
	public <name>(<if(recMems)><recMems; separator=", "><endif>) {
    	<if(recMemNames)><recMemNames:{n | this.<n> = <n>}; separator = ";\n">;<endif>
	}
}
>>

RecordMember(type, name) ::= "<type> <name>"

RecordAccess(protocolName, caseName, record, field) ::= "((<protocolName>.<caseName>) <record>.data).<field>"

RecordLiteral(name, params) ::= <<
new <name>(<if(params)><params; separator=", "><endif>)
>>

LookupSwitchTable(cases) ::= <<
<if(cases)>
switch(this.runLabel) {
	case 0: break;
    <cases; separator = ";\n">;
}<endif>
>>

LookupSwitchCase(caseNum) ::= <<
case <caseNum>: resume(<caseNum>); break
>>

ProcParam(parWsName, index, paramNumber, param) ::= <<
ProcParam(<parWsName>[<index>], <paramNumber>, <param>)
>>


ProcGetParam(type, name, number) ::= <<
<type> <name> = ProcGetParam(<number>, <type>)
>>

ParBlock(parCnt, parName, stats, barriers, jmp0, jmp1) ::= <<
label(<jmp0>);	
final Par <parName> = new Par(<parCnt>, this);
<if(barriers)><barriers:{b | <b>.enroll(<parCnt>)}; separator = ";\n">;<endif>
	
<stats; separator=";\n">;
	
setNotReady();
this.runLabel = <jmp1>;
yield();
label(<jmp1>)
>>

AnonymousProcess(parName, lookupswitch, body, barriers, parfor) ::= <<
new Process(){
	public synchronized void run() {
		<lookupswitch>
		<if(body)><body; separator = ";\n">;<endif>
      	terminate();
	}
	
	<if(parName)>
	public void finalize() {
		<parName>.decrement();	
		<if(barriers)><barriers:{b | <b>.resign()}; separator = ";\n">;<endif>
	}
	<endif>
}<if(!parfor)>.schedule()<endif>
>>

ReturnStat(expr, procYields) ::= <<
<if (procYields)>
terminate();
return<\\>
<else>
return<if(expr)> <expr><endif><\\>
<endif>
>>

SwitchLabel(constExpr, defaultExpr) ::= <<
<if(constExpr)>case <constExpr><endif><if(defaultExpr)><defaultExpr><endif>:
>>

SwitchGroup(labels, stmts) ::= <<
  <labels; separator = "\n">
    <stmts; separator = ";\n">;
>>

SwitchStat(expr, isProtocolExpr, switchGroups) ::= <<
<if(isProtocolExpr)>
switch( <expr>.tag ){
<else>
switch( <expr> ){
<endif>
  <switchGroups; separator = "\n">
}
>>

SyncStat(barrier, jmp) ::= <<
<barrier>.sync(this);
this.runLabel = <jmp>;
yield();
label(<jmp>)
>>

Ternary(expr, trueBranch, falseBranch) ::= "<expr> ? <trueBranch> : <falseBranch>"

TimeoutStat(alt, name, delay, jmp) ::= <<
<name> = new Timer(this, <delay>);
<if(!alt)>
try {
	<name>.start();
	setNotReady();
	this.runLabel = <jmp>;
	yield();
} catch (InterruptedException e) {
	System.out.println("Timer Interrupted Exception!");
}
label(<jmp>)<\\>
<endif>
>>

UnaryPostExpr(expr, op) ::= "<expr><op>"

UnaryPreExpr(expr, op) ::= "<op><expr>"

Var(name, init) ::= "<if(name)><name><endif><if(name && init)> = <endif><if(init)><init><endif>"

WhileStat(expr, stat) ::= <<
while( <expr> ) {
  <stat; separator = ";\n">;
}
>>